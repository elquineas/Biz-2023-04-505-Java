# 메모용

## 과제 제출시
- 프로젝트제출시 리파지토리 프로젝트진입후 주소복사
- 그외 단일파일은 파일까지 진입후 주소복사


## DB 
 - PASS : !Biz8080

## 아스키코드
```
enter : 13
esc   : 27
```

## OSI 7계층
```
응용
표현
세션
전송
네트워크
데이터
물리
```


## CPU
- 제어장치
  메모리에서 데이터 주고받을때 사용
- 연산장치(ALU)



----------------



## method, 함수(function)
- 여러 명령문을 그룹(코드블록{})으로 묶어 새로운 명령처럼
  사용한다
- method를 사용 하려면 먼저 method가 정의 되어야 한다
  정의 : public int num(int num1, int num2){
         return num1+num2}; 
  호출 : int result num(30, 40);
- method 실행 후 값을 return을 하면 결과를 다른 변수에
  저장할 수 있다
  int result = num(30,40);

- static이 없는 메소드는 다른곳에서 호출할때 보이지 않는다
  ex) MyClass. 으로 선언시
- Scanner(class) type의 객체(변수)를 선언
  Scanner(System.in) 생성자 method를 사용하여
  new로 초기화
  ex) Scanner scan = new Scanner(System.in);



----------------



## Entity(개체,객체)
- 관계형데이터베이스(RDBMS)에서 현실세계의 사람, 사물, 사건,
  개념 등의 유무형의 특성을 공유하는 독립적인 실체를 모델링하는 대상, 각 특징적인 부분을 속성(Attribute)으로 갖는다

## 추상화
- 현실세계의 존재하는 개체들의 특징을 유형화(Classification),
  집단화(Aggregation), 일반화(Generalization)하는 것으로,
  데이터 모델링에 앞서 개체를 구성하는 꼭 필요한 요소만을
  추출하는 것



----------------



## DBMS (DataBase Managiment System)
- 많은 데이터를 스토리지에 보관하 관리하는 소프트웨어
- 스토리지에 보관된 많은 데이터중에서 원하는 조건의 데이터를
  쉽게 조회할 수 있게 구성된 소프트웨어

## RDBMS (Relationship DataBase Managiment System)
- E(Entity)-R(Relation) 관계형 데이터베이스 시스템
- 많은 데이터를 관리하는 데이터베이스 소프트웨어중
  모든 데이터를 Table 이라는 관점으로 DB를 관리하는 시스템
- SQL(Structed Query Lang) 명령어를 사용하여 데이터를 관리

## NoSQL (Not Only SQL)
- RDMS의 Table구조 DB가 아닌 Document(SJON) 구조의 DB에
  데이터 저장
- 짧은 시간에 대량의 데이터를 추가하고 대량의 데이터를 
  분석 구조화 가능
  
  
  
----------------
  
  
  
## Module이란
- 모듈화를 통해 분리된 시스템의 기능들로
  서브루틴, 서브시스템, 함수, method등을 말한다

## Module의 결합도
- 모듈간에 상호 의존하는 정도 또는 두 모듈 사이의 연관관계

## Module의 응집도
- 정보 은닉 개념을 확장한 것으로, 명령이나 호출문 등 모듈의 
  내부 요소들의 서로 관련되어 있는 정도
- 모듈이 독립적인 기능으로 정의 되어있는 정도를 의미

## 잘 설계된 Module은?
- 결합도는 낮고, 응집도는 높아야한다.
  
  
  
----------------


## 아키텍트(Architect)
- 건축물을 설계하는 설계자에서 유래한 용어
- 프로젝트의 규모가 커져 여러개의 모듈을 개발해야 하는 경우,
  건축물의 구조를 설계하는 것처럼 전체적인 프로젝트의 구조적
  레아웃을 설계하는 사람
- 소프트웨어와 하드웨어 구성을 설계하고 구조화 하는 작업 수행

## 아키텍쳐(Architecture) 시스템 구조
- 시스템의 목적을 달성하기 위해 시스템의 상호작용등의 
  시스템디자인에 대한 제약 및 설계
- 최적화를 목표로 두고 시스템 구성과 동작원리, 시스템의 
  구성환경등을 설명 및 설계하는 청사진 또는 설계도


----------------



## 프로그래머(Programer)
- 코드작성, 분석 및 구현, 디버깅, 컴파일, 테스트 및 구현을 통해
  원하는 출력물을 만들어내는 일을 수행한다
- 시스템이 제대로 작동되기 위한 모든 다양한 요소의 영역을 다룬다
- 사소한 문제로 인해 발생할 수 있는 것들을 발견하고 예방한다
- 지속적인 자기계발을 통해 개발자, 아키텍트(Architect)로
  거듭나기 위해 노력한다

## 개발자(Developer)
- 다양한 유형의 문제를 해결하기 위한 시나리오와 절차를 만들고,
  다룬다
- 문제에 대한 솔루션을 개념화 하고 분석한 다음 문제 해결
  방법을 결정한다
- 코드분석, 디자인 패턴 등을 연구하고 본인의 것으로 습득
  향상시킨다


----------------


## 변수, 객체, 함수 및 속성 이름 작명 코딩 패턴
   : 이름 작성 Case 패턴
- 표준 Camel Case   : myName
- Upper Carmel Case : ServiceV1, ScoreService,
                      StudentService
- Kebab Case        : my-name, ham-button, top-menu
- 헝가리언 표기법    : intKor, strNation, bYes
- snack Case        : my_name
- Upper Case Format : MY_PROJECT_USER_NAME


----------------


## 객체
- 객체지향(OOP : Object Oriented Programming)
1. 현실세계의 Entity를 기계의 부품처럼 하나의 객체로 만들어
   기계적인 부품들을 조립하듯이 소프트웨어를 개발 할 때도 
   객체들을 조립하여 작성할수 있는 기법을 말한다

- 데이터
1. 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다.
2. 속성(Attribute), 상태, 변수, 상수, 자료구조라고도 한다.

- 함수
1. 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상태)를
   처리하는 알고리즘이다
2. 객체의 상태를 참조하거나 변경하는 수단이 되는 것으로 
   메소드(행위), 서비스(service), 동작(Operation), 연산
   이라고 한다


----------------


## 객체지향(Object-oriented Programming, OOP)이란
1. 컴퓨터 프로그래밍 페러다임의 한가지
2. 컴퓨터 목록을 명령어의 목록으로 보는 시각에서 탈피
3. 프로그래밍에서 필요한 "데이터를 추상화"하고, 
   "상태(데이터)"와 "행위(메소드)"를 가진 "객체"를 생성하고,
   객체들 간의 유기적인 상호 작용을 통해 문제를 해결하는
   프로그래밍 방법
4. 객체들 간에는 "메세지"를 주고 받으며 데이터를 처리
5. 유지보수를 쉽게 하여 "소프트웨어 위기"를 벗어나는 한가지 
   방법으로 인식
6. "추상화","상속","정보은닉과 캡슐화", "다양성"등의 특징이
   있다
 

----------------


## 객체지향(Object-oriented Programming, OOP) 장 단점
### 장점
- 코드 재사용 용이
1. 이미 잘 만들어진 클래스를 사용할 수 있고 상속을 받아 확장하여 사용할 수 있다.
- 유지보수가 쉽다
1. 절차 지향(구조적) 프로그래밍에 비해 수정해야할 부분을 쉽게 찾고 변경할 수 있다.
- 대형 프로젝트에 적합하다
1. 클래스 단위로 모듈화가 쉽기 때문에 협업과 업무 분담이 쉽다
### 단점
1. 처리속도가 절차 지향보다 상대적으로 늦다.
2. 객체가 많아 지면 용량이 커질 수 있다.
3. 추상화 등의 객체 설계를 하는데 많은 시간과 노력이 필요하다
   설계를 잘 하지 못하면 절차 지향보다 프로젝트를 성공하기 어렵다


----------------


## 객체지향의 5가지 키워드
- 추상화
1. 현실세계를 컴퓨터 프로그래밍 화하는 단계
2. 불필요한 정보는 버리고, 중요한 정보만 간추려 공통 속성 
   기능을 묶는 단계
- 캡슐화
1. 서로 관련된 기능과 특성을 한고셍 모으고 분류하여 재활용을
   용이하게 하는 것
- 정보 은닉
1. 캡슐화된 정보에 직접 접근하지 못하도록 하고, 우회로를 통해
   접근하여 정보를 보호하는 것
- 상속
1. 이미 견고하게 잘 만들어진 클래스를 가져와 자신만의 기능을
   추가 확장하여 사용하는 것
2. 단순 복사 붙이기와 차별화된 것
- 다형성
1. 같은 이름을 가지고 있지만 서로 다른 일을 하도록 구현하는 것
2. 사용하는 측에서는 데이터의 타입에 관계없이 이름을 호출하여 
   원하는 결과를 얻을 수 있음


----------------


## 다형성(OverLoading)
- 객체지향의 중요한 개념중 한가지
- method의 다형성 : 매개변수의 개수, type이 다르면
  같은 이름의 Method를 중복하여 선언 할 수 있다
  public void add(int num1);
  public void add(int num1), int num2;
- 객체의 다형성
  상속받은 클래스는 부모 클래스 type으로 생성이 가능하다
  Parents obj = new Parents();
  Children obj = new Children();
  Parents obj = new Children();


----------------


## 클래스와 인스턴스(객체)
- 클래스
1. 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거처
   속성, 행위를 변수와 메서드 개념으로 정의 한 것

- 인스턴스(객체)
1. 클래스에 정의된 것을 토대로 하여 실제 정보처리 연산을 
   수행하는데 사용되는 데이터
2. 클래스 또는 인터페이스 Type으로 선언하고 생성자를 호출하여 
   초기화 한 상태
   StudentVo stVo = new StudentVO();
   Service service = new ServiceImpl();



----------------


## 인터페이스(interFace)
1. 팀 프로젝트에서 코드 규약을 정의한다
2. 여러 구현체에서 사용하는 공통적인 부분을 추상화한다
   클래스의 다형성 이라고 한다
3. 객체간의 연결,소통을 돕는 중간역할을 한다
4. 메서드의 프로토 타입만 정의한다
5. 메서드의 구체적인 코드가 없다
6. 인터페이스를 상속(Implements)하는 구현체 클래스는
   인터페이스에 정의된 모든 메서드를 반드시 구현해야 한다
7. 클래스의 다형성을 가능하게 하여 코드간 결합도를 낮출 수 있다.


----------------


## interface를 사용한 class 다형성 구조
1. Java의 interface
- 클래스를 정의하기 위한 설계도 역할을 수행하는 특별한 class
- interface를 implements(상속)한 클래스는
  interface에 정의된 모든 method를 반드시 선언(작성)해야한다.
2. interface를 사용한 객체의 다형성
- interface는 implemnts한 클래스들의 Parent 이다
- interface로 객체를 선언하고,
  inplements한 클래스의 생성자로 인스턴스를 생성한다.
- 업그레이드된 클래스를 사용하고자 하면 생성자만 교체하면
  다른 코드는 그대로 사용가능하다


----------------


## 생성자 method
1. 클래스를 사용하여 객체(object) 선언후 인스턴스화 할때
   호출하는 method
2. 생성자 method는 return type(void, int, String 등)이 없다
3. 클래스 이름과 같다.(첫글자 대문자)
4. 클래스를 선언하면 "기본생성자"는 자동으로 선언된다
5. "임의 생성자"를 선언하면 기본 생성자를 선언해 주어야 한다
6. 생성자에서는 인스턴스변수(클래스 영역의 변수)를 초기화 하는 
   코드가 포함된다


----------------


## 객체의 독립성
1. 클래스를 통해 선언 및 생성된 객체는
   추상화된 Data(변수)와 행위(메서드)를 포함한다
2. 생성된 객체는 독립적이며, 가른 객체에 대하여 비정상적인 
   접근을 허용하지 않는다
3. 객체는 1개일 수있고, 배열과 리스트를 통하여 다수의 
   객체일 수 있다.
4. 배열 요소에 "저장된" 각각의 객체는 다른 요소의 객체와 
   완전 독립적이다
5. 리스트 요소에 "추가된" 각각의 객체는 다른 요소의 객체와 
   완전 독립적이다


----------------


## PRIBARY KEY
1. 기본 키(PK)를 설정하여 데이터 조작에 유일한 절대성을 
   부여하는 것
2. 한 레코드의 데이터를 수정, 삭제하여도 다른 레코드에 영향을 
   미치지 않는다. 이를 무결성 유지 라고 한다
3. 기본키의 값은 유일(UNIQUE)해야 하며 NOT NULL 성질을 갖는다.
4. 자동으로 Unique Index가 설정된다.
5. 한개의 Table에 1개만 존재한다


----------------


## 데이터 영역(Data segment) 또는 Static 영역
1. 애플리케이션이 실행되면서 필요한 변수가 저장되는 영역.
2. 애플리케이션이 구동되는 동안 항상 접근 가능 한 영역
3. 클래스 영역에 선언된 전역변수와 정적변수 영역

## 스택 영역(Stack segment)
1. 메서드, 함수 내에 정의된 지역변수가 저장되는 영역.
2. 메서드. 함수가 호출될 때 할당되고 종료될 때 해제된다.

## 힙(Heep segment) 영역
1. 동적 할당 영역
2. 인스턴스, 배열 등 참조 변수들이 저장되는 영역.
3. 객체 배열을 생성하는 실제 데이터는 Heap에 저장되고 저장소의
   주소는 스택에 저장된다


----------------


## 오류(Error)
1. 코딩 문법 오류로 인한 "컴파일"시 오류와 "런타임"시 널포인트
   참조와 같은 오류가 있으며 심각한 문제를 야기 시켜 프로세스
  (애플리케이션)가 종료되거나 중단된다
2. 시스템 에러(Error)는 컴퓨터 하드웨어의 오동작 또는 고장으로 
   인해 응용프로그램에 이상이 생겼거나 JVM실행에 문제가 생겼을 
   경우 발생한다.
3. 코딩 문법 오류는 IDE가 알려주거나 컴파일 단계에서 발견된다
4. 런타임시 오류는 사전에 개발자가 미리 예측하기 어려운 경우가 
   많기 떄문에 문법 상 간제 상황을 제외하고 애플리케이션의 
   런타임 오류에 대한 처리(해결)를 하지 않는 경우가 많다.
5. 오류가 발생하는 상황을 항상 미리 예측하여 적절한 Exception 
   핸들링 하는 것이 좋다

## 예외(Exception) 처리
1. 예외 상환도 오류와 같이 응용프로그램, 프로세스를 종료 시키는 
   것은 유사하다
2. 개발자가 예측할 수 있는 상황이 많으며, 적절한 처리
   (Exception Handling)를 수행하여 최소한 응용프로그램, 
   프로세스가 종료 되거나 중단되지 않도록 해야한다.
3. Exception 처리가 잘 되어 프로세스 종료를 최대한 방지하는 
   것이 좋은 애프릴케이션이다.


----------------


## 클린코드
1. 읽기 쉬운 코드가 클린코드이다
2. 우아한 코드 : 군더더기 없이 깔끔하다는 의미
3. 효과적 코드 : 기능을 수행하는 코드를 최대한 작고 짧은 라인으로 구현한다
4. 클린코드의 가장 중요한 요소 중 하나는 가독성이다.
   즉, 모든 팀원이 이해 하기 쉽도록 작성된 코드이다

## 클린코드 원칙
1. Coding 표준, 아키텍쳐 표준 및 설계 가이드 준수
2. 단순한 것이 효율적이다. 복잡함을 최소화 하라
3. 캠핑장을 떠나기전 원래보다 꺠끗하게 하라
   창조되거나 수정되는 코드는 원래보다 clean해야한다.
4. 항상 근본적인 원인을 찾아라. 그렇지 않으면 같은일을 
   반복하게 된다
5. 하나의 파일은 하나의 언어로 작성하라


----------------


## 클린코드의 주요원칙
- S : Simple Responsibility Principle(SRP)
      하나의 클래스는 하나의 책임만 가져야 한다
- O : Open/Closed Principle(OCP)
      클래스는 확장에 대하여 열려있어야하고, 변경에 
      대해서는 닫혀있어야한다
- L : Liskov Substitution Principle(LSP)
      파생 클래스의 메소드는 기반 클래스의 메서드를 
      대체하여 사용될 수 있어야한다
- I : Interface Segregation Principle(ISP)
      클라이언트가 사용하지않는 메소드에 의존하지 않아야한다
- D : Dependency Inversiont Principle(DIP)
      추상화된 것은 구체적인 것에 의존하면 안된다.
      (자주 변경되는 구체적인 거셍 의존하지 말고 
       추상화된것을 참조)


----------------


## Hyper Text
- 문서에 Anchor가 부착된 단어를 표기하고, Anchor를 클릭했을때 연관이 있는 문서를 열어보는 구조
- HTML(Hyper Text Markup Lang.)을 사용하여 문서를 작성하고
주로 Web Browser를 사용하여 문서 읽기

## HTML(Hyper Text Markup Lang.)
- Hyper Text 문서를 작성하는 특화된 구조의 언어 문법
- Tag로 감싸진 Content를 표현하는 언어문법
- Tag를 통하여 문서의 모양, 구조를 형성


----------------


## SQL (Structed Query Lang.)
1. RDBMS에 접근하기 귀한 데이터베이스 코딩 언어
2. DDL, DML, DCL, TCL 등이 있다.

## DDL (Data Definition Lang.)
1. 데이터저장소, Table, 사용자, 인덱스 등 데이터베이스 객체(Object) 생성, 제거, 변경
2. CREATE: 생성,
   DROP  : 제거,
   ALTER : 변경

## DML (Data Manipulation Lang.)
1. 생성된 데이터 Table을 기준으로 CRUD 실행
2. INSERT (Create, 추가),
   SELECT (Read, 조회),
   UPDATE (Update, 변경),
   DELETE (Delete, 삭제),

## DCL (Data Control Lang.)
1. 데이터베이스의 접근권한 등을 설정
2. GRANT  : 권한부여, 
   REVOKE : 권한회수


----------------


## UI(User Interface)
- 사용자가 제품이나 서비스를 사용할때, 마주하게 되는 것
- 사용자가 제품이나 서비스와 상호작용할 수 있도록 만들어진 매개체
- UI디자인은 폰트,칼라,레이아웃과 같이 사용자가 마주하게 될 시각적인 디자인

## UX(User Experience)
- 사용자 경험의 약자로, 사용자가 어떠한 서비스나 제품을 직간접적으로 이용하면서 느끼는 종합적인 만족을 의미
- UX디자인란 사용자에게 만족스러운 경험을 제공하는 UI를 디자인하는 것
- 사용자가 만족할 수 있도록 사용자 중심적으로 설계된 디자인
- 기존의 경험을 바탕으로 새로운 제품이나 서비스를 쉽게 사용할 수 있도록 해야한다.


----------------


## 비동기 실행
1. 어떤 식당에 서빙을 하는 직원이 한 명 있다
2. A 손님이 식당에 들어와 자리에 앉는다
3. 서빙 직원이 손님에게 주문을 받고, 주방에 주문을 전달한 후 서빙직원은 기다린다
4. 이때 다른 B손님이 들어와 테이블에 앉는다
5. 주방에서 주문이 완료되는 동안 B 손님에게서 주문을 받는다
6. A손님의 주문이 완료되고 조리된 음식을 A손님 테이블로 옮긴다
7. A손님이 식사하는 동안 기다린다
8. B손님의 주문이 완료되고 조리된 음식을 B손님 테이블로 옮긴다
9. B손님이 식사를 하는동안 A손님은 식사를 마치고 카운터에서 계산을 마무리한


----------------


## API
1. API (Application Programming Interface, 
   응용 프로그래밍 인터페이스)는 컴퓨터와 컴퓨터간 
   컴퓨터와 컴퓨터 프로그램 사이의 연결이다
2. 일종의 소프트웨어 인터페이스이며 다른 종류의 소프트웨어에
   서비스를 제공한다.
3. 이러한 연결이나 인터페이스를 빌드하거나 사용하는 방법을
   기술하는 문서나 표준을 API 사양으로 부른다
4. 표준을 충족하는 시스템은 API가 구현(implement)되었다가 
   노출(expose)되었다고 말한다.
   API라는 용어는 사양이나 구현체를 의미할 수 있다.

## OPEN API
1. Open Application Programming Interface는 개발자라면 
   누구나 사용할 수 있도록 공개된 API를 말하며, 개발자에게
   사유 응용소프트웨어나 웹 서비스의 프로그래밍 적인 권한을
   제공한다
2. 하나의 웹 사이트에서 자신이 가진 기능을 이용할 수 있도록
   공개한 프로그래밍 인터페이스가 오픈 API다 라고 
   정의할 수 있다.
3. 네이버 지도, 구글맵, 오픈스트리트맵 등이 대표적인 예이다.
   지도 서비스 및 다양한 서비스들에서 시도되고 있으며 누구나 
   접근하여 사용할 수 있다는 장점이 있다.


----------------


## GET method
1. GET은 서버로부터 정보를 조회하기 위해 설계되었다
2. URL 주솓에 쿼리스트링(?변수 = 값&변수 = 값) 형식으로 전송한다
   GET은 요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리 스트링을 통해 전송한다
3. 단순한 값을 정송할 때 사용한다.
4. 모든 데이터가 노출되어 보안에 취약하다. 민감정보는 절대 담아서는 아된다.
5. 전체 길이는 255자를 넘지 못한다.

## POST method
1. POST는 리소스를 생성/변경하기 위해 설계되었다.
2. HTTP 프로토콜의 Body에 데이터를 실어서 전송한다
3. 보통 form tag로 둘러쌓인 input tag에 입력된 값을 전송할 때 사용한다.
4. 전송하는 데이터가 표면상으로 노출되지 않는다.
5. 전송하는 데이터의 크기에 제한이 없다. 그림파일등도 전송할 수 있다.
6. 전송하는 데이터를 암호화 하여 전송하기 용이하다.



----------------


## URI (Uniform Resource Idenrifier, 통합 자원 식별자)
1. 인터넷에 있는 자원을 나타내는 유일한 주소.
2. URI의 존재느 인터넷에서 요구되는 기본조건으로서 인터넷
   프로토콜에 항상 연결
3. 하위개념인 URL, URN을 포함

## URL (Uniform Resource Locator)
1. 많은 네트워크 상에서 자원이 어디있는지를 알려주기 위한 규약
2. 즉, 컴퓨터 네트워크와 검색 메커니즘에서의 위치를 지정하는 웹 리소스에 대한 참조

## URN (Uniform Resource Name)
1. urn:scheme을 사용하는 URI를 위한 역사적인 이름이다. URN은 
   영속적이고, 위치에 독립적인 자원을 위한 지시자로 사용하기 
   위해 1997년도 RFC 2141문서에서 정의되었다.


----------------


## 관계형데이터베이스(RDBMS)
1. 기본구성이 Table
2. 키(key)와 값(value)들의 간단한 관계를 테이블화 시킨 매우 간단한 원칙의 데이터베이스
   각 Table은 Key,Value 쌍으로 데이터 표현
3. 데이터 간의 종속성을 Relation ship으로 표현
4. 데이터의 완전한 무결성이 보장되어야 하는 곳에서 주로 사용
5. 오라클, MySQL, CUBRID,MSSQL, Postgress 등이 있다

## NoSQL
1. 테이블 형식 스키마를 사용하지 않는다
2. 데이터의 속성, Type이 변화 되었을 때 변화에 빠른 대응이 가능하고, 확장이 용이하다.
3. 대량의 데이터(Big Data)를 수집하고, 분석하는 곳에서 주로 사용한다.
4. 다만 데이터의 일관성을 항상 보장 받을 수 없다.
5. mongoDB, 하둡(Gadoop)등이 있다.


----------------


## MVC(Model View Controllor) 패턴 기반 FullStack
1. 사용자가 Web을 통해 Request(요청)를 하면
2. DBMS를 통해 데이터를 SELECT 하고
3. SELECT 된 데이터를 객체(Model)에 담아 View로 보내 rendering(html 변환) 한 후
   UI(시각적 표현, 화면구현)로 Response
4. Model View Controller 패턴은 요구사항이 변경되더라도 상호간에 최소한의 영향만으로
   프로젝트가 구현되어야 한다
5. View는 사용자와 상호작용하며 Controller(router)는 데이터 처리와 
   비즈니스 로직(연산)을 담당한다.


----------------


## 프레임워크(FrameWork)
1. 차,비행기,배같은 탈것과 같은 잘 만들어진 "운송 수단"이라고 생각하면 된다.
2. 여행을 하려면 운송 수단에 사람이 탑승하여 시동을 걸고, 기어를 넣고, 핸들을 작동하고, 
   운전을 해야한다.
3. 하지만 , 운송 수단은 서로 대체할수 없다.
4. 하늘을 날려면 비행기를 타야하고, 도로를 달리려면, 자동차가 훨씬 유용하다. 
   바다에서는 배를 타야만 한다.
5. 애초에 그 목적에 맞게 만들어졌기 때문에, 톱이나 망치를 가지고 탈 것을 
   처음부터 직접 만들 필요를 없게 한다.
6. 정해진 규칙에 따라 시동 걸고, 기어를 넣고, 핸들을 돌리기만 하면 된다.
7. 즉, 프레임워크는 이미 프로그래밍할 규칙이 정해져 있는 모듈을 활용하여 규칙에 맞도록 
   개발자의 아이디어를 구현하는데 도움을 주는 있는 도구이다.


----------------


## Http Status Code, Response Code
- 200 : 데이터를 준비하고 있으니 기다려
- 302 : Redurect 할께
  304 : Redurect 할께, 변경된 내용이 없음
- 400 : 매개변수 오류
  401 : 권한오류
  403 : 권한오류
  404 : 요청을 처리할 method가 없음, 응담학 URI(URL)이 없음
  405 : URI는 있으나 RequestMethod(GET, POST, PUT, DELETE)가 없음
- 500 : 서버 내부 오류



----------------


## WAS(Web Aookucatuib Servuce, Server)
### WEB
1. 인터넷 기반의 정보기술로 World Wide Web의 줄임말이며 WWW 라고도 한다.
2. 전세계 거대한 TCP/IP 네트워크 망(MASH)을 통해 정보를 공유한다

### Web Apllication
1. 웹브라우저를 통해서 실행되는 응용프로그램.
2. 인터넷을 통한 은행업무, 인터넷 쇼핑, 민원신청 등이 여기에 속한다.
3. PC 환경에서 실행되던 응용프로그램이 Web 환경으로 이전되고 있다.
4. 사용자가 요청(Request)을 하면 서버에서는 요청을 분석하여 적절한
   비즈니스 로직을 수행하고 사용자에게 결과를 응답(Response)한다.
5. 웹 브라우저, 웹 서버, 웹 어플리케이션 서버, 데이터베이스 서버 등이 
   통합된 환경으로 운영된다.


----------------


## Spring MVC 패턴
### 목표
`<a href="${rootPath}/book/list">목록보기</a>` 
링크를 클릭하여 /view/book/list.jsp 열어보기

### Controller 클래스 생성하기
```
@Controller
@RequestMapping(Value="/book")
public class BookController{}
```

### Method 생성하기
```
@RequestMapping(Value="/list")
public String list(){
  return "book/list";
}
```


----------------


## 상태가 없는 HTTP 프로토콜
1. HTTP 프로토콜은 클라이언트의 요청이 있을때 만 서버가 응답을 한다.
2. 무(無) 상태(stateless) : 요청/응답이 완료되면 클라이언트와 서버는 어떤 연결도 유지하지 않는다.
   클라이언트가 이전 요청과 같은 데이터를 원한다고 하더라도 다시 서버에 연결을 하여
   동일한 요청을 시도해야만 한다.
3. 비(非) 연결(connectionless) : 또한 요청/응답이 완료되면 클라이언트와 서버는 즉시 연결이 종료된다.
4. 무 상태, 비연결 구조의 HTTP에서 사용자 인증을 처리하기 위해서는 매 요청마다
   사용자 정보를 어딘 가에 담아서 보내고, 서버는 매 요청마다 사용자 정보가 정상인지
   판단하는 절차를 통과해야 한다.
   많은 사용자 요청이 있을 경우 서버는 많은 비용을 지불해야 할 수 있다.
5. 초기의 HTTP 프로토콜에서는 URL에 사용자정보를 함께 실어서 요청을 했었다.
   `http://username:password@www.exampl.com/`
   지금은 사용하지 않으며 해당요청은 브라우저에서 거부한



----------------


## HTTP에서 상태 유지 기법 - 쿠키(cookie)
1. 서로의 연결성과 상태 유지하지 서버와 클라이언트가 로그인을 처리하기 위한 방법으로
   쿠키는 웹 브라우저가 보관하는 데이터이다.
2. 웹 서버는 로그인한 사용자 정보가 담긴 쿠키를 생성하여
   웹 브라우저에 정보를 내려 보낸다.
3. 웹 브라우저 쿠키는 Key-Value(변수-값) 형태로 브라우저의 쿠키 저장소에 저장한다.
4. 웹 브라우저는 이후 동일한 주소의 웹 서버에 요청을 보낼때 저장소에 있는
   쿠키를 헤더에 실어서 함께 전송한다.
5. 웹 서버는 요청 헤더에 담긴 쿠키정보를 확인하고 로그인 된 사용자로 인식한다.
6. 웹 서버와 클라이언트는 필요한 값을 공유하고 상태를 유지한다.
7. 쿠키는 "TEXT 형태로 교환되므로 네트워크에서 탈취"되기 쉽다.
8. 웹 브라우저에 접근할 수 있는 누구나 쿠키를 열어보고 내용을 알아낼 수 있다.
9. 탈취된 쿠키는 변형되거나 악의적인 용도로 사용될 수 있다.


----------------


## HTTP에서 상태 유지 기법 - 세션(Session)
1. 세션도 쿠키와 마찬가지로 클라이언트의 상태를 저장하고 상태를 유지하는 용도로 사용한다
2. 웹 브라우저는 각각 별도의 고유의 값을 갖는다
3. 각 세션에 고유 ID를 생성하고, 웹 서버는 각 브라우저에 세션 ID가 담긴 쿠키를 내려보낸다
   Tomcat에서 발급하는 쿠키의 Key는 JSESSIONID 입니다
4. 웹 브라우저는 웹 서버에 연결할 때 세션 ID 가 담긴 쿠키를 함께 전송한다
5. 웹 서버는 요청 헤더에 담겨있는 세션 ID를 확인하고 세션 저장소에 보관중인 데이터를 조회하여 상태를 유지한


## 쿠키와 세션의 중요한 차이 - 로그인 성공후
1. 쿠키는 로그인한 사용자 정보를 Text 문자열로 생성하여 브라우저에 전송하고
   브라우저는 쿠키 저장소에 사용자 정보를 문자열로 저장한다
2. 세션은 로그인한 사용자 정보를 서버의 메모리에 저장하고
   저장소 ID 정보를 쿠키에 담아 브라우저에 전송한다
3. 브라우저는 쿠키 저장소에는 세션의 ID 값만 저장이 되어 있다.
4. 서버로 전송된 쿠키에 담긴 세션 ID를 사용하여 서버 메모리에서 사용자 정보를 조회한다


## HTTP에서 상태 유지 기법 쿠키(cookie)
1. 서로의 연결성과 상태 유지하지 않는 서버와 클라이언트가 로그인을 처리하기 위한 방법으로
   쿠키는 웹 브라우저가 보관하는 데이터이다
2. 웹 서버는 로그인한 사용자 정보가 담긴 쿠키를 생성하여 웹 브라우저에 정보를 내려보낸다.
3. 웹 브라우저 쿠키는 Key-Value(변수-값) 형태로 브라우저의 쿠키 저장소에 저장한다
4. 웹 브라우저는 이후 동일한 주소의 웹 서버에 요청을 보낼 때
   저장소에 있는 쿠키를 헤더에 실어서 함께 전송한다.
5. 웹 서버는 요청 헤더에 담긴 쿠키정보를 확인하고 로그인 된 사용자로 인식한다
6. 웹 서버와 클라이언트를 필요한 값을 공유하고 상태를 유지한다
7. 쿠키는 'Text 형태로 교환되므로 네트워크에서 탈취'되기 쉽다.
8. 웹 브라우저에 접근할 수 있는 누구나 쿠키를 열어보고 내용을 알아낼 수 있다
9. 탈취된 쿠키는 변형되거나 악의적인 용도로 사용될 수 있다.


----------------


## Transaction 1

### 정의
1. 한가지 업무를 수행하는데 다수의 데이터 조작(CRUD)가 필요할 경우 이를 논리적인 단위로 묶은 것
### 성질
1. Atomic(원자성) : 트랜잭션이 모두 완료되어 COMMIT 되던지,
                    ROLLBCK ALL 되어 모두 반영되지 않아야 한다.
2. Consistency(일관성) : 트랜잭션이 성공하면 데이터 일관성이 보장되어야 한다.
3. Isolation(독립성) : 트랜잭션이 완료되기 전에는 다른 트랜잭션에서 참조 할 수 없다.
4. Durabliity(영속성) : 성공한 트랜잭션의 결과는 시스템이 고장 나더라도 유지 되어야한다.

### Commit
1. 트랜잭션이 모두 성공했을 때 로컬 스토리지의 물리적 데이터를 갱신하는 것, 실질적으로 데이터를 저장

### RollBack
1. 트랜잭션이 중간에 실패했을 때 처음 상태로 되돌리는 것, DB 변경사항을 모두 원점으로 복귀


----------------


## Transaction 2

### 병행처리(여러 트랜잭션의 동시 수행) 문제
1. 갱신 내용 손실 : 하나의 데이터가 동시에 갱신될 때 갱신이 누락되는 문제
2. 현황 파악 오류 : 데이터 갱신이 완료되지 않았는데 다른 트랜잭션이 데이터를 조회하는 문제
3. 모순성 : 데이터의 일관성이 때져 모순된 상태로 남는 문제
4. 연쇄 복귀 : 두 트랜잭션 중 한 곳에서 롤백이 되면, 다른 트랜잭션도 롤백되는 문제

### 병행처리 문제방지
1. 로깅 제어 기법을 사용한다
2. 트랜잭션이 시작할 때 필요한 데이터를 모두 Lock을 걸고 시작하는 것
3. 공유로깅 : 읽기만 허용하는 Lock
4. 배타로깅 : 읽기, 쓰기 모두 금지하는 Lock


----------------


## 정규화

### 목적
1. 데이터의 중복을 최소화
2. Insert, Delete, Update 이상 현상을 방지
3. 데이터베이스 구조 변경 확장 시 대 디자인 최소화
4. 데이터 모델을 사용자에게 더욱 의미 있게
5. 다양한 질의 지원

### 정규화 요약
1. 제1정규화 : 각 칼럼들의 값이 원자 값을 갖도록 한다.
2. 제2정규화 : 부분 함수 종속성을 제거
3. 제3정규화 : 기본키를 제외한 속성들 간에 이행적 함수 종속 제거
4. BCNF 정규화 : 결정자이며 후보키가 아닌 것을 제거
5. 제4정규화 : 다치 종속 제거

### 함수 종속성
1. 테이블의 속성(칼럼)간의 관계에서 속성A에 의해 속성B가 결정될 때 B는 A에 함수적으로 종속



----------------


## TDD(Test Driven Developer) 테스트 주도 개발
1. 주요 코드를 작성하기 전에 코드를 실행하여 얻게(return) 되는 값을 예상하고
   테스트 코드를 작성한 후 주요 코드를 작성하는 개발 방법론
2. 테스트 코드를 작성하면 주요 코드들에 대해 수시로 빠르게 검증을 받을 수 있으며,
   유지보수 및 리팩토링을 할 때에도 안정성을 확보할 수 있다는 장점이 있다.
3. 큰 장점으로 개발 및 테스팅에 대한 시간과 비용을 절감할 수 있다는 점에 주목해야 한다.

## DDD(Domain Driven Design) 도메인 주도 설계
1. 도메인과 일치하도록 소프트웨어를 모델링하는 데 중점을 둔 소프트웨어 설계 접근 방식이다.
2. 중요한 특징은 소프트웨어 코드의 구조와 언어(클래스 이름, 클래스 메소드, 클래스 변수)가
   비즈니스 도메인의 용어를 일치시켜 나간다는 점이다.
   예를들어 소프트웨어가 대출 응용 프로그램을 처리하는 경우
   대출 실행과 고객관리와 같은 클래스와 대출 승인과 대출 거절 같은 업무 프로세스가 있다.


----------------


## 블랙박스 테스트
1. 소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어의 동작을 검사하는 방법
2. 검사 진행에 있어 해당 소프트웨어의 코드나 내부 구조에 대한 정보는 필요하지 않으며, 
   특징 요구사항 검사를 위해 공개된 설계도 등의 대외적으로 공개된 사항들을 통해 검사를 진행한다
3. 이 소프트웨어는 무슨 역할이 수행되어야 하는가? 와 같이 소프트웨어의 특징이나 요구사항 등에 
   초점을 맞춰 검사가 이뤄진다
4. 개발자입장이 아닌 사용자 입장에서 소프트웨어 혹은 제품에 대한 요구사항과 결과물이 
   일치하는지 확인하기위한 테스트 기법이다

## 화이트박스 테스트
1. 소프트웨어 혹은 제품의 내부구조, 동작을 세밀하게 검사하는 테스트 방식으로, 
   외부에서 요구사항에 따른 예상 결과값을 테스트 하는 것과는 다르게 내부 소스 코드를 테스트하는 기법으로 
   사용자가 들여다 볼 수 없는 구간의 코드 단위를 테스트한다
2. 개발자가 소프트웨어 또는 컴포넌트 등의 로직에 대한 테스트를 수행하기 위해 설계 단계에서 
   요구된 사항을 확인하는 개발자 관점의 단위테스팅 기법이다.


----------------


## 개발 방법론( 결함 검토, 산출물 검토)
### 워크 쓰루
1. 개발 산출물을 작성하는 중에 산출물을 검토하고 결함을 찾아내는 기법
   주로 작성자의 요청에 의해 이루어지며 중간 산출물을 대상으로 한다
2. 후속 작업에 대한 검사가 생각될 수 있다
3. 인스펙션에 비해 비형식적인 동료 검토 방법이다
### 인스펙션
1. 작성자 외의 다른 전문가가 검사하는 가장 공식적인 리뷰 기법
2. 문서화된 절차를 기반으로 소프트웨어 명세를 만족하는지 검증
3. 코딩 전까지는 소요 인력 2배 이상 필요하나 추후 인력 감소로 인해 결과적으로
   품질 비용이 감소하고 개발 기간이 단축 된다.
4. 인스펙션 구성원 중 경영자는 제외(표면적 오류만 찾아내려는 경향 발생)


----------------


## 주니어 개발자의 자세
### 코드 리딩과 라이팅
1. 코드 리딩 : 만들어진 소스코드를 리딩하고 명명규칙 파악하기 협업에서 가장 중요
2. 잘 정돈되고 직관적이며 네이밍이 잘된 코드 작성하기
   내 코드는 혼자 보는게 아니다
3. 내가 만든 코드는 누가 봐도 쉽게 이해할 수 있어야 한다

### 생산성
1. 개발은 시간 싸움이다 : 야근은 필수가 아니라 선택이다
2. 환상적인 코드보다 빨리 완성된 코드가 좋은 코드이다.
   단 버그가 없어야 한다.

### 커뮤니티
1. 코딩 = 개발 ? NO : 협업
2. 누군가 나와 대화를 할때 숨이 막혀 한다면 ? 
3. 사소한 대화를 하는 동안 아이디어가 떠오르고, 문제해결이 된다면?

### 업무관리
1. 개발자는 개발자만 하는 사람이 아니다.
2. 세상의 모든 직업은 부수적인 업무관리가 필수적이다.
3. 본업무가 아니더라도 가장빠릴 마무리 할 수 있는 방법을 항상 연구하라

### 지속적인 학습
1. 학습은 좋은 개발자가 계속 좋은 개발자로 남는 길이다
2. 학습은 보통 개발자가 좋은 개발자가 될 수 있는 중요한 요소이다



----------------


## Clean Code의 주요원칙(General)
- Follow Standard Conventions : Coding 표준, 아키텍처 표준 및 설계 가이드를 준수하라.
- Keep It Simple, Stupid(KISS) : 단순한 것이 효율적이며, 복잡함을 최소화하라.
- Boy Scout Tule : 캠핑장을 떠나기 전에 원래보다 깨끗하게 해야한다.
                   (참조되거나 수정되는 코드는 원래보다 Clean 해야함)
- Root Cause Analysis : 항상 근본적인 원인을 찾아라. 그렇지 않으면 반복될 것이다.
- Do Not Miltiple Languages 
  In One Source File : 하나의 파일은 하나의 언어로 작성하라. 
                       (Java, JavaScript, Html ...)


----------------


## Spring Container
1. Container 는 Spring 의 핵심이다
   Container 는 개발자를 대신하여, Bean 을 생성, 관리, 제거 한다
2. Container 가 Bean 을 관리해주기 때문에,
   개발자는 모듈간에 의존 및 결합으로 인해 발생하는 문제로부터 자유로워진다.
3. 독립적인 코드를 작성해서 Annotation 만 남겨주면
   Container 가 개발자가 원하는 상황에 코드를 실행한다.
4. 개발자는 메서드가 언제, 어디서 호출되어야 하는지 
   그리고 메서드를 호출하기 위해서 필요한 매개 변수를 준비해서 전달하지 않는다.
   Container 가 개발자 대신 알아서 호출한다
5. 개발자가 Container  개념 즉, Spring framework 의 설계를 이해해야 하는 이유는 
   Container 가 겉으로 드러나지 않기 때문에 처음 Spring을 접하면 작동 원리를 이해하기 어렵다.


----------------


## Container

### Servlet Container
1. 웹서버와 통신하기 위해서 소켓을 생성하고, 특정 포트에 리스닝하고, 
   스트림을 생성하는 등의 복잡한 일들을 할 필요가 없게 해준다.
2. servlet의 생성부터 소멸까지의 일련의 과정(Lifer Cycle)을 관리 한다
3. 대표적인 Servlet Container - Tomcat 이 있다

### Spring Container
1. 자바 객체를 담고있다.
2. 언제든지 스프링 컨테이너로 부터 필요한 객체를 가져와 사용할 수 있다.
3. Bean들의 생명주기를 관리한다
4. Spring Container는 어플리케이션을 구성하는 Bean들을 관리하기 위해 IoC를 사용한다.


----------------


## Spring MVC 패턴

### 목표
- <a> 링크를 클릭하여 페이지 열어보기
### Controller
- @Controller
  @ReauestMapping(value="")
### Method 생성하기
- @ReauestMapping(value="")
  public String list(){
    return "book/list"
  }


----------------


## 협업을 위한 코딩 스타일
### Pascal Case
1. 첫 글자를 대문자로
2. 단어를 조합할 때 두번째 단어부터 첫 글자 대문자
3. Camel Case와 혼용하여 부르기도 한다. 이때 Upper Camel Case 라고 부르기도 한다
4. C++에서 함수 명 작성할때 사용
5. Java에서 클래스, 인터페이스, Enum을 작성할 때 사용
6. 예 : public class KorScore
### Camel Case
1. 첫 글자를 소문자로
2. 단어를 조합할 때
   두번째 단어부터 첫 글자 대문자
3. Java에서 변수, method, 객체 이름에 사용
4. 예 : int korScore, engScore
### 헝가리언 표기법
1. 주로 변수명을 지을 때 사용
2. 변수 명 첫 단어를 변수 Type으로 시작
3. 예 : int iNum, int intNum


----------------


## UI 프로그래밍 패러다임
### 명령형 UI, 명령형 프로그래밍
명령형 프로그래밍이란 프로그램의 상태와 상태를 변경시키는 구문의 관점에서 연산을
설명하는 프로그래밍 패러다임의 일종이다
쉽게 설명하자면, 컴퓨터가 수행할 명령들을 순서대로 써놓은 것이라고 볼 수 있다.
이러한 명령형 프로그래밍은 "how to solve it", 즉 어떻게 그것을 해결할 것인가에 관심이 있다.

### 선언형 UI, 선언형 프로그래밍
1. 웹페이지는 제목, 글꼴, 본문, 그림과 같이 "무엇"이 나타나야하는지를 묘사하는 것이지
   "어떤 방법으로" 컴퓨터 화면에 페이지를 나타내야 하는지를 묘사하는 것이 아니기 때문에 
   선언형 프로그래밍으로 분류한다
2. 프로그램이 함수형, 논리형, 제한형 프로그래밍 언어 등으로 작성된 경우에 선언형 이라고 한다.


----------------


## ReactJS
### 컴포넌트(1)
- 리액트로 만들어진 앱을 이루는 최소하느이 단위
- 기존의 웹 프레임워크는 MVC방식으로 분리 관리하지만
  각 요소의 의존성이 높아 재활용이 어렵다는 단점이 있었다
- 컴포넌트는 MVC의 뷰를 독립적으로 구성하여 재사용을 할 수 있고
  이를통해 새로운 컴포넌트를 쉽게 만들 수 있다.
- 컴포넌트는 데이터 입력받아 상태(state)에 따라 view(state)의 
  DOM Node를 Rendering 하는 함수 단위이다. (초기 React는 class 단위 였으나 공식적으로 함수단위를 권장한다)


----------------


## 일취월장 코딩능력
- 책을보고 코딩하기
  절대 따라치지 않기, 눈을 감으면 코드가 보일 때까지 읽기
- 동영상 보고 코딩 익히기
  드라마, 영화를 보는 것처럼 머리속에 남을때까지 보기만 하기

- 검색한 코드 복제하기
  ctrl + c, ctrl + v 하지 않기
  화면의 코드를 보면서 내 프로젝트에 옮겨 입력하기
  변수 이름 바꿔보기, 함수 이름 바꿔보기, 파일이름 바꿔보기
  

----------------


## ReactJS
### 컴포넌트(2)
- 리액트로 만들어진 앱을 이루는 최소한의 단위
- 개발자가 만든 컴포넌트 이름은 항상 대문자로 시작하도록 한다.
  (리액트는 소문자로 시작하는 컴포넌트를 DOM태그로 취급하기 때문)
- UI를 재사용 가능한 개별적인 여러 조각으로 나누고,
  각 조각을 개별적으로 나누어 코딩한다.
- "props"라고 하는 임의의 입력을 받은 후,
  화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반복한다


----------------


## Javascript fetch 함수 비동기 방식으로 실행
```js
fetch("http://example.com/user/info")
.then(response => response.json())
.then(result => console.log(result))

```
1. WebAPI 인 fetch 함수를 사용하여 example.com 서버에 user 정보(info)를 요청한다
2. Event loop에 의해 fetch 함수와 1번 response => response.json() 함수와 
   2번 result => console.log(result) 함수의 코드가 call stack에 push 된다.
3. fetch 함수는 오류가 없으면 즉시 종료되고 call stack 에서 제거된다.
4. 서버에서 응답이 오면 1번 함수가 실행되고 response 결과에서 json 데이터를 추출한후 return
   1번 함수 코드도 call stack 에서 제거된다.
5. return 된 결과를 2번 함수 코드에서 console 에 출력한 후 2번 함수도 call stack 에서 제거된다.

## Javascript fetch 함수 동기 방식으로 실행
```JS
const response = await fetch("http://example.com/user/info");
const result = await response.json();
console.log(result);
```
1. ES5 이상에서는 Promise 를 사용하여 동기적으로 실행이 가능하다
2. 비동기 call back 을 사용하지 않고 async, await 조합으로 동기 실행이 가능하다


----------------


## Data가 포함된 Java 프로젝트
1. Data 추상화 : 사용할 Data중 필요한 항목이 무엇인지 파악한다
2. Data 클래스 작성 : 추상화 된 데이터를 기준으로 DTO, VO, Entity 클래스를 작성한다.
3. Service 클래스 작성
 - Data 생성 method
 - 생성된 Data 확인 method
 - 생성된 Data에 대한 연산 method
4. Controller 클래스 작성
 - main() mehtod 를 작성하고 Service 클래스와 연결
 - Data 생성, Data 확인, 연산후 Data 확인, 최종 결과 출력 확인


----------------


## Where 조건 절
1. WHERE 절은 SELECT, UPDATE, DELETE 에서 사용한다
2. 조건 식을 부여하여 특정한 조건에 맞는 데이터만 조회, 수정, 삭제를 하기 위해 사용한다
3. 일부 JOIN 식에서 사용하기도 한다
4. UPDATE, DELETE 명령에는 가급적 PK를 기준으로 조건을 설정하는 것이 좋다
   SELECT * FROM 테이블 A WHERE A.칼럼 = 값
   DELETE FROM 테이블 A WHERE A.PK = 값

## ON 조건 절
1. OUTER JOIN 에서 테이블 간의 JOIN 기준을 설정할 때 사용한다
   SELETE * FROM 테이블 A LEFT (OUTER) JOIN 테이블 B A.칼럼 = B.칼럼
   SELETE * FROM 테이블 A RIGHT (OUTER) JOIN 테이블 B A.칼럼 = B.칼럼


----------------




----------------




----------------




----------------




----------------




----------------




----------------





















